                                    ------
                                 Tutorial on Maven2
                                    ------
                                  Max VÃ¶lkel
                                    ------
                                   6.1.2007

What is Maven2?

  Maven2 is a complete re-implementation of Maven.
  Maven is a declarative, plugin-based dependency-resolution and 
  build-management system.  
  
Maven Features                      
  
  * Declarative?

  The <project object model> (POM) is a declarative model in
  XML-syntax which specifies the properties of a project, such as
  name, id, version, description, mailing lists, bug tracker,
  developers, plugin configurations and dependencies.
  
  * Plugin-based?

  Maven consists of many plugins itself. Of course, the plugins
  are also managed with Mavens own depenency-resolution mechanism.
  
  * Dependency resolution?
  
  Maven has the idea of a central repository, which holds all JARs on earth.
  Right now, this repository is hosted at ibiblio and has about 10 GB.
  Mirrors exist. Each maven project has three coordinates: groupID,
  artefactId and version. Together, they uniquely identify a particular
  deployable (e.g. JAR) piece of software.
  At compilation time Maven fetches all necessary dependencies from a
  repository. And the dependencies of the dependencies. For this to work,
  two conditions must hold:
      
      * the dependency must be in the repository
      
      * the repository must be online
  
  As both might fail, Maven has also a <<local>> repository, which 
  is like a cache for the global one. If a library is not yet in the
  global repository or the global repository is offline, then one
  can manually deploy libraries into the local repository.
  
  * Build management system?

  Maven can compile your code, run all tests, generate millions 
  of reports and create a neat, comprehensive website from the POM.                

What you need

  * Eclipse 3.2.x
  
  * Subclipse - the Eclipse plugin for SVN
   
  * An Ontoware account to access the SVN
  
  * Maven2 - read below
 
Installing Maven

  * I assume you have already checked out the semweb4j-trunk to
  your hard disk. Let's assume it's at <<P:\semweb4j-svn\trunk>>.

  * Download Maven from {{http://maven.apache.org/download.html}}

  * Go to <<<C:\Documents and Settings\username\.m2>>> (your home directoy) and
  put a file called <<settings.xml>> there with 

+--------------------------------+
<settings>
  <localRepository>P:/semweb4j-svn/trunk/maven-repo/</localRepository>
</settings>
+--------------------------------+

  * Set system properties: 

+--------------------------------+
M2_HOME=C:\app\dev\maven-2.0.4
MAVEN_OPTS=-Xmx512m
+--------------------------------+

  The second is needed for using the memory-hungry report plugins,
  in particular the findbugs-plugin.

  * Test Maven by going to <<P:/semweb4j-svn/trunk/org/semweb4j/rdf2go>> and calling
  <<mvn help:effective-settings>>. You should get an XML file dumped, which 
  represents the POM of rdf2go plus the POM of semweb4j-parent plus some
  built-in definitions of Maven itself.

{Running Maven}

  Simply go to a directory (on the command line) where a POM is and
  call <<mvn>> <command>, e.g. <<mvn validate>>.

{Life Cycle}

  Maven has the idea of a software lifecycle, which is built-in.
  Each phase calls the phases before. Maven phases are:
 
  * validate Validate the project is correct and all necessary information is available. 
 
  * initialize Initialize the build process. 
 
  * generate-sources Generate any source code for inclusion in compilation. 
 
  * process-sources Process the source code, for example to filter any values. 
 
  * generate-resources Generate resources for inclusion in the package. 
 
  * process-resources Copy and process the resources into the destination directory, ready for packaging. 
 
  * compile Compile the source code of the project. 
 
  * process-classes Post-process the generated files from compilation, for example to do byte code enhancement on Java classes. 
 
  * generate-test-sources Generate any test source code for inclusion in compilation. 
 
  * process-test-sources Process the test source code, for example to filter any values. 
 
  * generate-test-resources Create resources for testing. 
 
  * process-test-resources Copy and process the resources into the test destination directory. 
 
  * test-compile Compile the test source code into the test destination directory 
 
  * test Run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed. 
 
  * package Take the compiled code and package it in its distributable format, such as a JAR. 
 
  * pre-integration-test Perform actions required before integration tests are executed. This may involve things such as setting up the required environment. 
 
  * integration-test Process and deploy the package if necessary into an environment where integration tests can be run. 
 
  * post-integration-test Perform actions required after integration tests have been executed. This may including cleaning up the environment. 
 
  * verify Run any checks to verify the package is valid and meets quality criteria. 
 
  * install Install the package into the local repository, for use as a dependency in other projects locally.
  
     * I use this quite often to publish a project's content to the local
     repository, which is where Eclipse picks it up.
 
  * deploy Done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.
  
{Eclipse}

  Maven and Eclipse are not yet a dream-team. You will use the command
  line often, so get used to it. What you can do for Eclipse is:
  
  From the menu bar, select <Window > Preferences>. 
  Select the <Run/Debug > String Substitution>. 
  Add a new variable e.g. <maven_exec>. 
  When you set up a new external launcher 
  (from the menu bar, select <Run > External Tools>. Select <Program>) 
  you can refer to <maven_exec> in the location field. 
  Furhtermore refer to <project_loc> as the working directory and 
  specify the maven goals of your choice as arguments, 
  e.g. <eclipse:eclipse>. 
  
  Don't install any Maven-Eclipse-Plugins. They all don't work.
  
  Running <<mvn eclipse:eclipse>> will generate the <<.project>> 
  and <<.settings>> files for Eclipse 3.2.x. Re-running on existing
  project files will not ruin them, just the dependencies (referenced projects
  and libraries) are changed.
  
{Standard Directory Layout}  
  
  Maven defines a standard layout. Other layouts are possible, but require
  more configuration work. So please stick to the official.
  
+-----------------------------------------------+
  /project
    /src - things you edit
       /main 
         /java  - Java source code
         /resources - also in the classpath, but not Java source code
       /test  - things to test the stuff in main.
         /java  - JUnit tests and such
         /resources - also in the classpath, but not Java source code
       /site  - defines the web site
         /apt  - will be copied to site root and converted to html
         /resources  - will be copied to site root 'as is'
       /assembly - configures how stuff is packaged
    /target - stuff that is generated. don't touch.
    pom.xml - the POM  
+-------------------------------------------------+
         
  Usually you should only work in <</src/main>> and <<src/test>>.
  
{Defining Dependencies}

  The hardest part is to find out if someone already put it into the
  central repository and what name he might have choosen.
  
  The central is at {{ http://mirrors.ibiblio.org/pub/mirrors/maven2/}}.
  The URL for a dependency is constructed like <</groupId/artefactId/version>>, so 
  when looking for something with groupId = <org.apache> you look at
  <<http://mirrors.ibiblio.org/pub/mirrors/maven2/org/apache/>>. 
  
  * It's much faster to go to this sub-directory then to browse the root.
  
  * The groupId is often the reverse-URL like package names (recommended by Maven)
  but in reality also often simply the project name (legacy naming). E. g.
  I found the DOM4J libraries as groupId="dom4j" artefactId="dom4j", so they
  were at <<http://mirrors.ibiblio.org/pub/mirrors/maven2/dom4j/dom4j/>>.         
  
  If you finally <<found a pom.xml>> file, open it and copy the section
  
+-------------------------------+   
		<groupId>org.semweb4j</groupId>
		<artifactId>semweb4j-parent</artifactId>
		<version>4.3-SNAPSHOT</version>
+-------------------------------+
  from the header.  
  
  If you <<cannot find the project>>, e.g. Jena 2.4 is not there, Jena 2.3 is.
  So if we want to add Jena 2.4 to Maven, we must 
  
  * find something like jena.jar
  
  * install it manually to the local repository via

+-----------------------------------+  
mvn install:install-file -Dfile=jena.jar -DgroupId=net.sourceforge.jena -DartifactId=jena -Dversion=2.4 -Dpackaging=jar
+-----------------------------------+		
  which will copy it to
  
+-----------------------------------+
P:\semweb4j-svn\trunk\maven-repo\net\sourceforge\jena\jena\2.4\jena-2.4.jar
+-----------------------------------+

  Unfortunately, this is not enough. We also have to tell Maven which jars
  are needed by the jena.jar. For this, we create a <<pom.xml>> and put
  it in the same directory as jena-2.4.jar. In the pom.xml we write
  (the full file is in the SVN:

+-----------------------------------+
<!-- the next definitions allows Eclipse XML plugins to
     offer autocompletion for the XML structure, really helpful! -->
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">

    <!-- This line must always be like this for Maven 2 -->
    <modelVersion>4.0.0</modelVersion>

    <!-- the coordinates, must match the strings given in the mvn install command -->
		<groupId>net.sourceforge.jena</groupId>
		<artifactId>jena</artifactId>
		<version>2.4</version>

    <!-- always jar -->
    <packaging>jar</packaging>
    
    <!-- some prose for nicer debug outputs here and there -->
    <name>Jena</name>
    <url>http://jena.sourceforge.net</url>
    <description>Jena is a Java framework for building Semantic Web
        applications. It provides a programmatic environment for RDF, RDFS and
    OWL, including a rule-based inference engine.</description>

    <!-- the real part: dependencies -->
    <dependencies>
	  <!-- internal dependencies, these were also deployed by hand -->
  	  <dependency>
		<groupId>net.sourceforge.jena</groupId>
		<artifactId>arq</artifactId>
		<version>1.4</version>
	  </dependency>
	  <dependency>
		<groupId>net.sourceforge.jena</groupId>
		<artifactId>iri</artifactId>
		<version>2.4</version>
	  </dependency>
	<dependency>
		<groupId>com.ibm.icu</groupId>
		<artifactId>icu4j</artifactId>
		<version>3.4.4</version>
	</dependency>

	<!-- external dependencies, found in ibiblio -->
      <dependency>
          <groupId>antlr</groupId>
          <artifactId>antlr</artifactId>
          <version>2.7.5</version>
      </dependency>
	<dependency>
		<groupId>xerces</groupId>
		<artifactId>xercesImpl</artifactId>
		<version>2.7.1</version>
	</dependency>
	<dependency>
		<groupId>concurrent</groupId>
		<artifactId>concurrent</artifactId>
		<version>1.3.4</version>
	</dependency>
        <dependency>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
            <version>1.0.4</version>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.12</version>
        </dependency>
	<dependency>
      	<groupId>stax</groupId>
      	<artifactId>stax-api</artifactId>
      	<version>1.0.1</version>
    </dependency>
        <dependency>
  	<groupId>org.codehaus.woodstox</groupId>
  	<artifactId>wstx-lgpl</artifactId>
  	<version>3.1.1</version>        
</dependency>
        <dependency>
            <groupId>xml-apis</groupId>
            <artifactId>xml-apis</artifactId>
            <version>1.3.02</version>
        </dependency>
    </dependencies>
</project>
+-------------------------------------+

Site

  Maven can handle the {{{apt.html}APT}} format.
  
Gotchas! Bugs I encountered

  Dependency resolution introduced two versions of Xerces. Reason?
  Both were coming from the group "xerces" but one artefact was named
  "xerces" the other "xercesImpl", so to Maven they were different
  libraries. 
  
  Solution: Go to the local repository and patch the POM manually.
  
Finding Maven ids for existing projects

  Simply look at {{http://www.mvnrepository.com/}}  
    