/**
 * generated by RDFReactor on 9:59 on 29.2005
 */
package org.ontoware.semversion;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.List;

import org.ontoware.aifbcommons.collection.ClosableIterator;
import org.ontoware.rdf2go.model.Diff;
import org.ontoware.rdf2go.model.Model;
import org.ontoware.rdf2go.model.Statement;
import org.ontoware.rdf2go.model.node.URI;
import org.ontoware.rdfreactor.runtime.Bridge;
import org.ontoware.rdfreactor.runtime.RDFDataException;
import org.ontoware.semversion.impl.SessionModel;
import org.ontoware.semversion.impl.SyntacticDiffEngine;
import org.ontoware.semversion.impl.generated.RDFModel;

/**
 * SemVersion Version
 * 
 * @author voelkel
 */
public class Version extends VersionedItem {

	private org.ontoware.semversion.impl.generated.Version version;

	public Version(Model model, URI uri, boolean write) {
		super(model, uri);
		this.version = new org.ontoware.semversion.impl.generated.Version(
				model, uri, write);
	}

	public Version(org.ontoware.semversion.impl.generated.Version version) {
		super(version.getModel(), version.getResource().asURI());
		this.version = version;
	}

	private boolean branchLabelExists(String branchLabel) {
		try {
			Version[] allVersions = this.getContainer().getAllVersion();
			for (int i = 0; i < allVersions.length; i++) {
				if (allVersions[i].getBranchLabel().equals(branchLabel))
					return true;
			}
		} catch (RDFDataException e) {
			throw new RuntimeException(e);
		}
		return false;
	}

	/**
	 * 
	 * @return if a commit conflict was detected, false otherwise
	 */
	protected boolean checkForCommitConflicts() {
		List<Version> children = this.getValidChildren();
		for (Version child : children) {
			if (this.isInSameBranch(child))
				return true;
		}
		return false;
	}

	/**
	 * @param diff
	 * @param comment
	 * @param versionURI
	 *            the contextURI of the new model
	 * @param provenance
	 * @param suggestion
	 * @return
	 * @throws CommitConflictException
	 */
	public Version commit(Diff diff, String comment, URI versionURI,
			URI provenance, boolean suggestion) throws CommitConflictException {
		if (!suggestion && isSuggestion())
			throw new InvalidChildOfSuggestionException();
		if (checkForCommitConflicts())
			throw new CommitConflictException();
		// apply diff
		Model content = getContent();
		Model temp = SyntacticDiffEngine.applyDiff(getSemVersion().getTripleStore(),
				content, diff);
		content.close();
		return commit(temp, comment, versionURI, provenance, suggestion);
	}

	public Version commit(Model childContent, String comment, boolean suggestion)
			throws CommitConflictException, InvalidChildOfSuggestionException {
		if (!suggestion && isSuggestion())
			throw new InvalidChildOfSuggestionException();
		if (checkForCommitConflicts())
			throw new CommitConflictException();
		return commit(childContent, comment, getSemVersion().getTripleStore()
				.newRandomUniqueURI(), null, suggestion);
	}

	/**
	 * commits a suggestion, setValid then creates a 'real' version
	 * 
	 * @param user
	 * @param childContent
	 * @param label
	 * @param versionURI
	 * @param v
	 * @param provenance
	 * @param suggestion
	 * @return the committed child version
	 */
	public Version commit(Model childContent, String comment, URI versionURI,
			URI provenance, boolean suggestion) {
		if (!suggestion && isSuggestion())
			throw new InvalidChildOfSuggestionException();
		if (checkForCommitConflicts())
			throw new CommitConflictException();

		Version child = new Version(getSemVersion().getMainModel(), versionURI,
				true);
		// add metadata
		try {
			// store model
			Model childModel = getSemVersion().getTripleStore()
					.addModelAndPersist(childContent);
			childContent.close();
			childModel.close();

			child.setUser(((SessionModel) this.version.getModel()).getSession()
					.getUser());
			child.setProvenance(provenance);
			child.setCreationTime(Calendar.getInstance());

			child.setChangeCause("commit");

			child.setComment(comment);
			child.setContainer(getContainer());
			if (!suggestion)
				child.setValid();

			// carry over branch label
			child.setBranchLabel(this.getBranchLabel());

			// link
			RDFModel childContentModel = new RDFModel(getSemVersion()
					.getMainModel(), childModel.getContextURI());
			child.setContent(childContentModel);
			this.version.addChild(child.version);
			child.setFirstParent(this);
			// add to root
			getContainer().addVersion(child);
			return child;
		} catch (RDFDataException e) {
			throw new RuntimeException(e);
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	void setChangeCause(String value) {
		this.version.setChangeCause(value);
	}

	public void setComment(String comment) {
		this.version.setComment(comment);
	}

	public Version commitAsBranch(Diff diff, String branchLabel,
			String comment, URI uri, URI provenance, boolean suggestion)
			throws BranchlabelAlreadyUsedException,
			InvalidChildOfSuggestionException {
		if (!suggestion && isSuggestion())
			throw new InvalidChildOfSuggestionException();
		if (branchLabelExists(branchLabel))
			throw new BranchlabelAlreadyUsedException();
		Version childVersion = commit(diff, comment, uri, provenance,
				suggestion);
		childVersion.setBranchLabel(branchLabel);
		return childVersion;
	}

	public Version commitAsBranch(Model childContent, String branchLabel,
			String comment, boolean suggestion)
			throws BranchlabelAlreadyUsedException,
			InvalidChildOfSuggestionException {
		if (!suggestion && isSuggestion())
			throw new InvalidChildOfSuggestionException();
		if (branchLabelExists(branchLabel))
			throw new BranchlabelAlreadyUsedException();
		Version childVersion = commit(childContent, comment, suggestion);
		childVersion.setBranchLabel(branchLabel);
		return childVersion;
	}

	public Version commitAsBranch(Model childContent, String branchLabel,
			String comment, URI versionURI, URI provenance, boolean suggestion)
			throws BranchlabelAlreadyUsedException,
			InvalidChildOfSuggestionException {
		if (!suggestion && isSuggestion())
			throw new InvalidChildOfSuggestionException();
		if (branchLabelExists(branchLabel))
			throw new BranchlabelAlreadyUsedException();
		Version childVersion = commit(childContent, comment, versionURI,
				provenance, suggestion);
		childVersion.setBranchLabel(branchLabel);
		return childVersion;
	}

	public String dump() {
		StringBuffer buf = new StringBuffer();
		try {
			Model content = getContent();
			ClosableIterator<Statement> iter = content.iterator();
			while (iter.hasNext()) {
				Statement s = iter.next();
				buf.append("\t" + s.getSubject() + "\t" + s.getPredicate()
						+ "\t" + s.getObject() + "\n");
			}
			iter.close();
			content.close();
			return buf.toString();
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	// //////////////////////////////////////////////////
	// versioning specific methods

	public boolean equals(Object other) {
		return ((other instanceof Version) && this.version.getResource()
				.equals(((Version) other).version.getResource()));
	}

	/**
	 * 
	 * @return __all__ children
	 */
	public Version[] getAllChildren() {
		return (Version[]) Bridge.getAllValues(version.getModel(), version
				.getResource(),
				org.ontoware.semversion.impl.generated.Version.CHILD,
				Version.class);
	}

	public String getBranchLabel() {
		return this.version.getBranchLabel();
	}

	/**
	 * returns the only value. null if none is found, RDFDataException, if the
	 * property has multiple values
	 */
	public VersionedModel getContainer() throws RDFDataException {
		return new VersionedModel(this.version.getContainer());
	}

	/**
	 * @return a an in-memory copy of the content
	 */
	public Model getContent() {
		return getSemVersion().getTripleStore().getAsTempCopy(
				getContentURI());
	}

	/**
	 * returns the only value. null if none is found, RDFDataException, if the
	 * property has multiple values
	 */
	public URI getContentURI() {
		return version.getContent().getResource().asURI();
	}

	/**
	 * returns the only value. null if none is found, RDFDataException, if the
	 * property has multiple values
	 * 
	 * @return predecessor, which is always a Version
	 */
	public Version getFirstParent() {
		org.ontoware.semversion.impl.generated.Version reactorVersion = version
				.getFirstParent();
		if (reactorVersion == null)
			return null;
		else
			return new Version(reactorVersion);
	}

	/**
	 * 'contrary' to getSuggestions
	 * 
	 * @return
	 */
	public List<Version> getNextVersions() {
		List<Version> result = new ArrayList<Version>();
		for (Version v : getAllChildren())
			result.add(v);
		return result;
	}

	/**
	 * 
	 * @return the first parent
	 */
	public Version getPrevVersion() {
		return getFirstParent();
	}

	public URI getProvenance() {
		return this.version.getProvenance();
	}

	/**
	 * @return the second parent (a Version) if this version has been the result
	 *         of a merge. Return null otherwise.
	 */
	public Version getSecondParent() {
		org.ontoware.semversion.impl.generated.Version secondParent = this.version
				.getSecondParent();

		if (secondParent != null
				&& org.ontoware.semversion.impl.generated.Version.hasInstance(
						version.getModel(), secondParent.getResource().asURI())) {
			return new Version(secondParent);
		} else
			return null;
	}

	public long getStatementCount() {
		Model m = getSemVersion().getTripleStore().getPersistentModel(
				getContentURI());
		long size = m.size();
		m.close();
		return size;
	}

	/**
	 * FIXME this method seems to return __all__ children --> should be fixed
	 * now
	 * 
	 * @return
	 */
	public List<Version> getSuggestions() {

		List<Version> suggestions = new ArrayList<Version>();
		Version[] allVersions = getAllChildren();
		for (int i = 0; i < allVersions.length; i++) {
			if (!allVersions[i].isValid())
				suggestions.add(allVersions[i]);
		}
		return suggestions;
	}

	public List<Version> getValidChildren() {
		List<Version> result = new ArrayList<Version>();
		for (Version v : getAllChildren()) {
			if (v.isValid())
				result.add(v);
		}
		return result;
	}

	public VersionedModel getVersionedModel() {
		try {
			return getContainer();
		} catch (RDFDataException e) {
			throw new RuntimeException(e);
		}
	}

	public boolean hasChildWithSameBranchLabel() {
		List<Version> validChildren = getValidChildren();
		for (Version v : validChildren) {
			if (v.getBranchLabel().equals(getBranchLabel()))
				return true;
		}
		return false;
	}

	public boolean hasValidChildren() {
		return getValidChildren().size() > 0;
	}

	public boolean isInSameBranch(Version other) {
		return getBranchLabel().equals(other.getBranchLabel());
	}

	public boolean isSuggestion() {
		return !isValid();
	}

	public boolean isValid() {
		try {
			return getTag() != null && getTag().equals(SemVersion.VALID);
		} catch (RDFDataException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Merge this version with 'other' version.
	 * 
	 * @param otherVersion
	 * @param comment
	 * @param provenance
	 * @param suggestion
	 * @return
	 * @throws CommitConflictException
	 * @throws InvalidChildOfSuggestionException
	 */
	public Version merge(Version otherVersion, String comment, URI provenance,
			boolean suggestion) throws CommitConflictException,
			InvalidChildOfSuggestionException {
		if (!suggestion && isSuggestion())
			throw new InvalidChildOfSuggestionException();
		if (checkForCommitConflicts())
			throw new CommitConflictException();
		try {
			URI childURI = getSemVersion().getMainModel().newRandomUniqueURI();
			Version child = new Version(getSemVersion().getMainModel(),
					childURI, true);

			// set metadata

			child.setUser(((SessionModel) this.version.getModel()).getSession()
					.getUser());
			child.setProvenance(provenance);
			child.setCreationTime(Calendar.getInstance());

			// link merge data
			child.setFirstParent(this);
			child.setSecondParent(otherVersion);

			child.setChangeCause("merge");
			this.version.addChild(child.version);

			Model childModel = getSemVersion().getTripleStore()
					.getAsTempCopy(getContentURI());
			// add otherVersion
			Model content = otherVersion.getContent();
			ClosableIterator<Statement> it = content.iterator();
			childModel.addAll(it);
			it.close();
			content.close();

			RDFModel childContent = new RDFModel(
					getSemVersion().getMainModel(), childModel.getContextURI());
			child.setContent(childContent);
			child.setContainer(getContainer());

			child.setComment(comment);

			if (!suggestion)
				child.setValid();

			getContainer().addVersion(child);
			return child;

		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	public void setAsRelease() {
		setValid();
	}

	public void setBranchLabel(String branchLabel) {
		version.setBranchLabel(branchLabel);
	}

	/**
	 * removes all values and sets this one
	 */
	void setContainer(VersionedModel value) {
		version.setContainer(value.getReactorVersionedModel());
	}

	/**
	 * removes all values and sets this one
	 */
	public void setContent(RDFModel rdfmodel) throws RDFDataException {
		version.setContent(rdfmodel);
	}

	/**
	 * removes all values and sets this one
	 */
	public void setFirstParent(Version value) throws RDFDataException {
		version.setFirstParent(value.getReactorVersion());
	}

	public void setInvalid() {
		version.removeAllTag();
	}

	/**
	 * removes all values and sets this one
	 */
	private void setSecondParent(Version value) throws RDFDataException {
		version.setSecondParent(value.getReactorVersion());
	}

	public void setValid() {
		try {
			setTag(SemVersion.VALID);

			// inherit branch label from parent
			if (this.getFirstParent() != null)
				this.setBranchLabel(this.getFirstParent().getBranchLabel());
			else
				// first version must be main branch
				this.setBranchLabel(SemVersion.MAIN_BRANCH);

		} catch (RDFDataException e) {
			throw new RuntimeException(e);
		}
	}

	public org.ontoware.semversion.impl.generated.Version getReactorVersion() {
		return this.version;
	}

	public String getLabel() {
		return this.version.getLabel();
	}

	public String getChangeCause() {
		return this.version.getChangeCause();
	}

}
