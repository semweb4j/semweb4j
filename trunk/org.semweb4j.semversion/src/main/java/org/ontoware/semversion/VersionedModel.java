/**
 * generated by RDFReactor on 9:59 on 29.2005
 */
package org.ontoware.semversion;

import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.ontoware.rdf2go.model.Model;
import org.ontoware.rdf2go.model.node.URI;
import org.ontoware.rdfreactor.runtime.Bridge;
import org.ontoware.rdfreactor.runtime.RDFDataException;
import org.ontoware.semversion.impl.generated.RDFModel;
import org.ontoware.semversion.Version;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A VersionedModel holds a version tree for an RDF model.
 * 
 * @author voelkel
 */
public class VersionedModel extends VersionedItem {

	private static Logger log = LoggerFactory.getLogger(VersionedModel.class);

	private org.ontoware.semversion.impl.generated.VersionedModel vm;

	public VersionedModel(Model model, Session session, URI uri, boolean write) {
		super(model, session, uri);
		this.vm = new org.ontoware.semversion.impl.generated.VersionedModel(
				model, uri, write);
	}

	public VersionedModel(
			org.ontoware.semversion.impl.generated.VersionedModel vm, Session session) {
		super(vm.getModel(), session, vm.getResource().asURI());
		this.vm = vm;
	}

	// ///////////////////
	// root

	private void addToBranch(Branch branch, Version leaf) {
		branch.fromRootToRecent.add(branch.fromRootToRecent.size(), leaf);
		if (leaf.getFirstParent() != null)
			addToBranch(branch, leaf.getFirstParent());
	}

	/**
	 * internal: keep a reference to the Version
	 */
	protected void addVersion(Version value) {
		this.vm.addVersion(value.getReactorVersion());
	}

	/**
	 * Convenience method for <code>
	 * commitRoot(Model root, String label, String comment, URI versionURI, URI provenance)
	 * </code>
	 */
	public Version commitRoot(Model root, String label)
			throws URISyntaxException {
		assert getSemVersion() != null;
		return commitRoot(root, label, "", getSemVersion().getTripleStore()
				.newRandomUniqueURI(), null);
	}

	// ////////////////////////////////
	// version

	/**
	 * Commit the root version to the version tree.
	 * 
	 * @param root
	 * @param comment
	 *            may be null
	 * @param versionURI
	 *            may not be null
	 * @param provenance
	 * @return a new Version with the content given in 'root'. The new version
	 *         has the versionURI and a comment.
	 * @throws IllegalStateException
	 *             if this VersionedModel has already a root version
	 */
	public Version commitRoot(Model root, String label, String comment, URI versionURI,
			URI provenance) {
		assert root != null;
		assert comment != null;
		if (versionURI == null) {
			throw new IllegalArgumentException("versionURI may not be null");
		}

		if (getRoot() != null)
			throw new IllegalStateException(
					"You tried to commit a root model, but I have already one: "
							+ getRoot()
							+ " Method call ignored, continue using existing root.");
		else {
			// create Version proxy
			Version version = new Version(getSemVersion().getMainModel(), getSession(),
					versionURI, true);

			// set all data
			version.setLabel(label);
			version.setComment(comment);
			User user = getSession()
					.getUser();
			log.debug("user: " + user.getName());
			assert user != null;
			version.setUser(user);
			version.setValid();
			version.setCreationTime(Calendar.getInstance());
			version.setContainer(this);
			if (provenance != null)
				version.setProvenance(provenance);

			// store content = create triple set & link
			Model rootModel = getSemVersion().getTripleStore()
					.addModelAndPersist(root);
			rootModel.close();
			URI rootModelURI = rootModel.getContextURI();
			RDFModel rdfmodel = new RDFModel(getSemVersion().getMainModel(),
					rootModelURI, false);
			version.setContent(rdfmodel);
			version.setChangeCause("commit");

			// link version
			assert version != null;
			assert getRoot() == null : "found root: " + getRoot();
			setRoot(version);
			assert getRoot() != null;
			addVersion(version);
			assert getRoot() != null;
			return version;
		}
	}

	/**
	 * Removes this VersionedModel and all versions in the version tree.
	 */
	public void delete() {
		try {
			Calendar now = Calendar.getInstance();
			setDeletionTime(now);
			// process versions
			for (Version v : getAllVersions())
				v.setDeletionTime(now);

		} catch (RDFDataException e) {
			throw new RuntimeException(e);
		}

	}

	/**
	 * Debugging help. Dumps all content on System.out.
	 */
	public void dump() {
		StringBuffer buf = new StringBuffer();
		buf.append("dump of versioned Model " + vm + "\n");
		buf
				.append("URI of Version\tlabel\tbranchlabel\tsuggestion\tparent\tnumber of children\n");
		for (Version v : getAllVersions()) {
			buf.append(v + "\t" + v.getLabel() + "\t" + v.getBranchLabel()
					+ "\t" + v.isSuggestion() + "\t" + v.getFirstParent()
					+ "\t" + v.getAllChildren().size() + "\n");
			buf.append(v.dump());
		}
		System.out.println(buf);
	}

	// ////////////////////////////////////////////////
	// OPERATIONS

	private boolean equalHelper(Object field1, Object field2) {
		if (field1 == null && field2 == null)
			return true;
		if (field1 == null && field2 != null)
			return false;
		if (field1 != null && field2 == null)
			return false;
		if (!field1.getClass().equals(field2.getClass()))
			return false;
		return field1.equals(field2);
	}

	@Override
	public boolean equals(Object other) {
		assert this.vm.getModel().isOpen();

		try {
			if (!(other instanceof VersionedModel)) {
				log.debug("other is a " + other.getClass());
				return false;
			}
			VersionedModel vm = (VersionedModel) other;
			if (!equalHelper(vm.getAllBranches(), getAllBranches())) {
				log.debug("different getAllBranches");
				return false;
			}
			if (!equalHelper(vm.getAllVersions(), getAllVersions())) {
				log.debug("different getAllVersions");
				return false;
			}
			if (!equalHelper(vm.getBranches(), getBranches())) {
				log.debug("different getBranches");
				return false;
			}
			if (!equalHelper(vm.getChangeLog(), getChangeLog())) {
				log.debug("different getChangeLog");
				return false;
			}
			if (!equalHelper(vm.getComment(), getComment())) {
				log.debug("different getComment");
				return false;
			}
			if (!equalHelper(vm.getCreationTime(), getCreationTime())) {
				log.debug("different getCreationTime");
				return false;
			}
			if (!equalHelper(vm.getDeletionTime(), getDeletionTime())) {
				log.debug("different getDeletionTime");
				return false;
			}
			if (!equalHelper(vm.getLabel(), getLabel())) {
				log.debug("different getLabel");
				return false;
			}
			if (!equalHelper(vm.getFirstVersion(), getFirstVersion())) {
				log.debug("different getFirstVersion");
				return false;
			}
			if (!equalHelper(vm.getLastMainbranchVersion(),
					getLastMainbranchVersion())) {
				log.debug("different getLastMainbranchVersion");
				return false;
			}
			if (!equalHelper(vm.getLastModifiedBy(), getLastModifiedBy())) {
				log.debug("different getLastModifiedBy");
				return false;
			}
			if (!equalHelper(vm.getLastVersions(), getLastVersions())) {
				log.debug("different getLastVersions");
				return false;
			}
			if (!equalHelper(vm.getLastModifiedBy(), getLastModifiedBy())) {
				log.debug("different getLastModifiedBy");
				return false;
			}
			if (!equalHelper(vm.getProvenance(), getProvenance())) {
				log.debug("different getProvenance");
				return false;
			}
			if (!equalHelper(vm.getRoot(), getRoot())) {
				log.debug("different getRoot");
				return false;
			}
			// if (!vm.getStatistics().equals(getStatistics()))
			// return false;
			if (!equalHelper(vm.getURI(), getURI())) {
				log.debug("different getURI");
				return false;
			}
			if (!equalHelper(vm.getTransactionTime(), getTransactionTime())) {
				log.debug("different getTransactionTime: "
						+ vm.getTransactionTime() + " vs. "
						+ getTransactionTime());
				return false;
			}
			if (!equalHelper(vm.getUserdefinedMetadata(),
					getUserdefinedMetadata())) {
				log.debug("different getUserdefinedMetadata");
				return false;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}

	/**
	 * @return a set of all branch labels used in the version tree.
	 */
	public Set<String> getAllBranches() {
		Set<String> branchLabels = new HashSet<String>();
		List<Version> allVersions = getAllVersions();
		for (int i = 0; i < allVersions.size(); i++) {
			branchLabels.add(allVersions.get(i).getBranchLabel());
		}
		return branchLabels;
	}

	/**
	 * @return a list of all versions in this version tree
	 */
	public List<org.ontoware.semversion.Version> getAllVersions() {
		org.ontoware.semversion.impl.generated.Version[] genVersions =
			(org.ontoware.semversion.impl.generated.Version[]) Bridge.getAllValues(vm.getModel(), vm.getResource(),
				org.ontoware.semversion.impl.generated.VersionedModel.VERSION,
				org.ontoware.semversion.impl.generated.Version.class);
		List<org.ontoware.semversion.Version> list = new ArrayList<org.ontoware.semversion.Version>();
		for (org.ontoware.semversion.impl.generated.Version vi : genVersions) {
			list.add( new org.ontoware.semversion.Version(vi, getSession()));
		}
		return list;
	}


	/**
	 * @return TODO unclear semantics
	 */
	public List<Branch> getBranches() {
		List<Branch> result = new ArrayList<Branch>();
		for (Version leaf : getLastVersions()) {
			Branch branch = new Branch();
			addToBranch(branch, leaf);
			result.add(branch);
		}
		return result;
	}

	/**
	 * @return a list of all changes that happened in this version tree
	 */
	public List<Change> getChangeLog() {

		List<Change> changes = new ArrayList<Change>();
		for (Version v : getAllVersions()) {

			String changeCause = v.getChangeCause();
			if (changeCause == null) {
				changeCause = "unknown";
			}
			Change c = new Change(v, changeCause);
			changes.add(c);
		}
		return changes;
	}

	private int getChildrenCount(Version root) {
		assert root != null;
		int childrenCount = 0;
		for (Version v : root.getAllChildren()) {
			childrenCount += getChildrenCount(v);
		}
		return childrenCount;
	}

	/**
	 * @return the root version, if any, or null
	 */
	public Version getFirstVersion() {
		try {
			return getRoot();
		} catch (RDFDataException e) {
			return null;
		}
	}

	/**
	 * @return the most recent version of the branch "main" or null, if no main
	 *         branch version exists. Root is automatically considered to be in
	 *         the "main" branch.
	 */
	public Version getLastMainbranchVersion() {
		return getLastVersionOfBranch(SemVersion.MAIN_BRANCH);
	}

	/**
	 * @return User who made the last modifications to this versioned model or
	 *         null if no versions are in the versioned model
	 */
	public String getLastModifiedBy() {
		if (getMostRecentVersion() == null)
			return null;
		else
			return getMostRecentVersion().getUser().getName();
	}

	/**
	 * @return the most recent version of the branch 'branchLabel' or null
	 */
	public Version getLastVersionOfBranch(String branchLabel) {
		for (Version v : getAllVersions()) {
			String brLabel = v.getBranchLabel();
			if (brLabel != null && brLabel.equals(branchLabel)
					&& !v.hasChildWithSameBranchLabel())
				return v;
		}
		return null;
	}

	/**
	 * @return all versions that have no children = all leaves of the version
	 *         tree
	 */
	public List<Version> getLastVersions() {
		List<Version> allVersions = new ArrayList<Version>();
		for (Version v : getAllVersions()) {
			if (v.getAllChildren().size() == 0)
				allVersions.add(v);
		}
		return allVersions;
	}

	/**
	 * @return a List of all users that are authors of a leaf version
	 */
	public List<User> getListLastModifiedBy() {
		List<User> result = new ArrayList<User>();
		for (Version v : getLastVersions())
			result.add(v.getUser());
		return result;
	}

	/**
	 * @return the most recent version of the version tree
	 */
	private Version getMostRecentVersion() {
		try {
			// for each Version in VersionedModel
			Calendar mostRecent = Calendar.getInstance();
			mostRecent.setTime(new Date(Long.MIN_VALUE));
			Version mostRecentVersion = null;
			for (Version v : getAllVersions()) {
				Calendar d = v.getCreationTime();
				if (d.after(mostRecent)) {
					mostRecent = d;
					mostRecentVersion = v;
				}
			}
			return mostRecentVersion;
		} catch (RDFDataException e) {
			throw new RuntimeException(e);
		}
	}

	protected org.ontoware.semversion.impl.generated.VersionedModel getReactorVersionedModel() {
		return this.vm;
	}

	/**
	 * @return the root version of the version tree or null, if none has been
	 *         set
	 */
	public Version getRoot() throws RDFDataException {
		org.ontoware.semversion.impl.generated.Version rootVersion = this.vm
				.getRoot();
		if (rootVersion == null)
			return null;
		else
			return new Version(rootVersion, getSession());
	}

	/**
	 * @return a Calendar set to the time when has the latest version of this
	 *         versionedmodel been modified
	 */
	public Calendar getTimestampLastModified() {
		// TODO a faster impl via SPARQL might be possible
		Version recent = getMostRecentVersion();
		return recent.getCreationTime();
	}

	/**
	 * Get a particular version from versionedmodel without having to iterate
	 * through all of the versions
	 * 
	 * @return the version with the given URI if it exists, otherwise null
	 */
	public Version getVersion(URI versionURI) {
		if (org.ontoware.semversion.impl.generated.Version.hasInstance(vm
				.getModel(), versionURI)) {
			return new Version(vm.getModel(), getSession(), versionURI, false);
		} else
			return null;
	}

	/**
	 * @return the number of different versions in the version tree
	 */
	public int getVersionCount() {
		Version root;
		try {
			root = getRoot();
			if (root == null) {
				log.debug("no root, no versions");
				return 0;
			}
			// recursive
			else
				return getChildrenCount(root) + 1;
		} catch (RDFDataException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * @return all versions in a list
	 */
	public List<Version> getVersions() {
		List<Version> vis = new ArrayList<Version>();
		for (Version vi : getAllVersions()) {
			vis.add(vi);
		}
		return vis;
	}

	/**
	 * 
	 * @param start
	 *            earliest creation date
	 * @param end
	 *            latest creation date
	 * @param user
	 * @return the list of Versions created between start and end by user user
	 * @throws RDFDataException
	 */
	public List<Version> queryForVersions(Calendar start, Calendar end,
			User user) throws RDFDataException {
		List<Version> vis = new ArrayList<Version>();
		for (Version vi : getAllVersions()) {
			if (vi.getCreationTime().compareTo(start) >= 0
					&& vi.getCreationTime().compareTo(end) <= 0
					&& vi.getUser().equals(user))
				vis.add(vi);
		}
		return vis;
	}

	/**
	 * removes all values and sets this one, used for testing only
	 */
	protected void setRoot(Version value) throws RDFDataException {
		assert value != null;
		vm.setRoot(value.getReactorVersion());
	}
}
