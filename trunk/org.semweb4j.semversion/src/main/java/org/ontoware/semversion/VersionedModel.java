/**
 * generated by RDFReactor on 9:59 on 29.2005
 */
package org.ontoware.semversion;

import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.ontoware.rdf2go.model.Model;
import org.ontoware.rdf2go.model.node.URI;
import org.ontoware.rdfreactor.runtime.Bridge;
import org.ontoware.rdfreactor.runtime.RDFDataException;
import org.ontoware.semversion.impl.SessionModel;
import org.ontoware.semversion.impl.UserImpl;
import org.ontoware.semversion.impl.generated.RDFModel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class VersionedModel extends VersionedItem {

	private static Logger log = LoggerFactory.getLogger(VersionedModel.class);

	private org.ontoware.semversion.impl.generated.VersionedModel vm;

	public VersionedModel(Model model, URI uri, boolean write) {
		super(model, uri);
		this.vm = new org.ontoware.semversion.impl.generated.VersionedModel(
				model, uri, write);
	}

	public VersionedModel(
			org.ontoware.semversion.impl.generated.VersionedModel vm) {
		super(vm.getModel(), vm.getResource().asURI());
		this.vm = vm;
	}

	// ///////////////////
	// root

	private void addToBranch(Branch branch, Version leaf) {
		branch.fromRootToRecent.add(branch.fromRootToRecent.size(), leaf);
		if (leaf.getFirstParent() != null)
			addToBranch(branch, leaf.getFirstParent());
	}

	/**
	 * adds a value
	 */
	public void addVersion(Version value) {
		this.vm.addVersion(value.getReactorVersion());
	}

	/* convenience method */
	public Version commitRoot(Model root, String label)
			throws URISyntaxException {
		assert getSemVersion() != null;
		return commitRoot(root, label, getSemVersion().getTripleStore()
				.newRandomUniqueURI(), null);
	}

	// ////////////////////////////////
	// version

	/* worker */
	public Version commitRoot(Model root, String comment, URI versionURI,
			URI provenance) {
		assert root != null;
		assert comment != null;
		assert versionURI != null;

		if (getRoot() != null)
			throw new RuntimeException(
					"You tried to commit a root model, but I have already one: "
							+ getRoot()
							+ " Method call ignored, continue using existing root.");
		else {
			// create Version proxy
			Version version = new Version(getSemVersion().getMainModel(),
					versionURI, true);

			// set all data
			version.setComment(comment);
			User user = ((SessionModel) this.vm.getModel()).getSession()
					.getUser();
			log.debug("user: " + user.getName());
			assert user != null;
			version.setUser(user);
			version.setValid();
			version.setCreationTime(Calendar.getInstance());
			version.setContainer(this);
			if (provenance != null)
				version.setProvenance(provenance);

			// store content = create triple set & link
			Model rootModel = getSemVersion().getTripleStore()
					.addModelAndPersist(root);
			rootModel.close();
			URI rootModelURI = rootModel.getContextURI();
			RDFModel rdfmodel = new RDFModel(getSemVersion().getMainModel(),
					rootModelURI, false);
			version.setContent(rdfmodel);
			version.setChangeCause("commit");

			// link version
			assert version != null;
			assert getRoot() == null : "found root: " + getRoot();
			setRoot(version);
			assert getRoot() != null;
			addVersion(version);
			assert getRoot() != null;
			return version;
		}
	}

	public void delete() {
		try {
			Calendar now = Calendar.getInstance();
			setDeletionTime(now);
			// process versions
			for (Version v : getAllVersion())
				v.setDeletionTime(now);

		} catch (RDFDataException e) {
			throw new RuntimeException(e);
		}

	}

	public void dump() {
		StringBuffer buf = new StringBuffer();
		buf.append("dump of versioned Model " + vm + "\n");
		buf
				.append("URI of Version\tlabel\tbranchlabel\tsuggestion\tparent\tnumber of children\n");
		for (Version v : getAllVersions()) {
			buf.append(v + "\t" + v.getLabel() + "\t" + v.getBranchLabel()
					+ "\t" + v.isSuggestion() + "\t" + v.getFirstParent()
					+ "\t" + v.getAllChildren().length + "\n");
			buf.append(v.dump());
		}
		System.out.println(buf);
	}

	// ////////////////////////////////////////////////
	// OPERATIONS

	private boolean equalHelper(Object field1, Object field2) {
		if (field1 == null && field2 == null)
			return true;
		if (field1 == null && field2 != null)
			return false;
		if (field1 != null && field2 == null)
			return false;
		if (!field1.getClass().equals(field2.getClass()))
			return false;
		return field1.equals(field2);
	}

	@Override
	public boolean equals(Object other) {
		assert this.vm.getModel().isOpen();
		
		try {
			if (!(other instanceof VersionedModel)) {
				log.debug("other is a "+other.getClass());
				return false;
			}
			VersionedModel vm = (VersionedModel) other;
			if (!equalHelper(vm.getAllBranches(), getAllBranches())) {
				log.debug("different getAllBranches");
				return false;
			}
			if (!equalHelper(vm.getAllVersions(), getAllVersions())) {
				log.debug("different getAllVersions");
				return false;
			}
			if (!equalHelper(vm.getBranches(), getBranches())) {
				log.debug("different getBranches");
				return false;
			}
			if (!equalHelper(vm.getChangeLog(), getChangeLog())) {
				log.debug("different getChangeLog");
				return false;
			}
			if (!equalHelper(vm.getComment(), getComment())) {
				log.debug("different getComment");
				return false;
			}
			if (!equalHelper(vm.getCreationTime(), getCreationTime())) {
				log.debug("different getCreationTime");
				return false;
			}
			if (!equalHelper(vm.getDeletionTime(), getDeletionTime())) {
				log.debug("different getDeletionTime");
				return false;
			}
			if (!equalHelper(vm.getLabel(), getLabel())) {
				log.debug("different getLabel");
				return false;
			}
			if (!equalHelper(vm.getFirstVersion(), getFirstVersion())) {
				log.debug("different getFirstVersion");
				return false;
			}
			if (!equalHelper(vm.getLastMainbranchVersion(),
					getLastMainbranchVersion())) {
				log.debug("different getLastMainbranchVersion");
				return false;
			}
			if (!equalHelper(vm.getLastModifiedBy(), getLastModifiedBy())) {
				log.debug("different getLastModifiedBy");
				return false;
			}
			if (!equalHelper(vm.getLastVersions(), getLastVersions())) {
				log.debug("different getLastVersions");
				return false;
			}
			if (!equalHelper(vm.getLastModifiedBy(), getLastModifiedBy())) {
				log.debug("different getLastModifiedBy");
				return false;
			}
			if (!equalHelper(vm.getProvenance(), getProvenance())) {
				log.debug("different getProvenance");
				return false;
			}
			if (!equalHelper(vm.getRoot(), getRoot())) {
				log.debug("different getRoot");
				return false;
			}
			// if (!vm.getStatistics().equals(getStatistics()))
			// return false;
			if (!equalHelper(vm.getURI(), getURI())) {
				log.debug("different getURI");
				return false;
			}
			if (!equalHelper(vm.getTransactionTime(), getTransactionTime())) {
				log.debug("different getTransactionTime: "+vm.getTransactionTime()+" vs. "+getTransactionTime());
				return false;
			}
			if (!equalHelper(vm.getUserdefinedMetadata(),
					getUserdefinedMetadata())) {
				log.debug("different getUserdefinedMetadata");
				return false;
			}
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}

	public Set<String> getAllBranches() {
		Set<String> branchLabels = new HashSet<String>();
		Version[] allVersions = getAllVersion();
		for (int i = 0; i < allVersions.length; i++) {
			branchLabels.add(allVersions[i].getBranchLabel());
		}
		return branchLabels;
	}

	/**
	 * returns all values
	 */
	public Version[] getAllVersion() {
		return (Version[]) Bridge.getAllValues(vm.getModel(), vm.getResource(),
				org.ontoware.semversion.impl.generated.VersionedModel.VERSION,
				Version.class);
	}

	public List<Version> getAllVersions() {
		Version[] versions = getAllVersion();
		List<Version> list = new ArrayList<Version>();
		for (Version vi : versions) {
			list.add(vi);
		}
		return list;
	}

	public List<Branch> getBranches() {
		List<Branch> result = new ArrayList<Branch>();
		for (Version leaf : getLastVersions()) {
			Branch branch = new Branch();
			addToBranch(branch, leaf);
			result.add(branch);
		}
		return result;
	}

	/**
	 * each version is the result of a change, other changes are not recorded
	 */
	public List<Change> getChangeLog() {

		List<Change> changes = new ArrayList<Change>();
		for (Version v : getAllVersion()) {

			String changeCause = v.getChangeCause();
			if (changeCause == null) {
				changeCause = "unknown";
			}
			Change c = new Change(v, changeCause);
			changes.add(c);
		}
		return changes;
	}

	private int getChildrenCount(Version root) {
		assert root != null;
		int childrenCount = 0;
		for (Version v : root.getAllChildren()) {
			childrenCount += getChildrenCount(v);
		}
		return childrenCount;
	}

	public Version getFirstVersion() {
		try {
			return getRoot();
		} catch (RDFDataException e) {
			return null;
		}
	}

	/**
	 * 
	 * @return last main branch version or null if even root is empty
	 */
	public Version getLastMainbranchVersion() {
		for (Version v : getAllVersion()) {
			String brLabel = v.getBranchLabel();
			if (brLabel != null && brLabel.equals(SemVersion.MAIN_BRANCH)
					&& !v.hasChildWithSameBranchLabel())
				return v;
		}
		return null;
	}

	/**
	 * @return User who made the last modifications to this versioned model or
	 *         null if no versions are in the versioned model
	 */
	public String getLastModifiedBy() {
		if (getMostRecentVersion() == null)
			return null;
		else
			return getMostRecentVersion().getUser().getName();
	}

	public Version getLastVersionOfBranch(String branchLabel) {
		for (Version v : getAllVersion()) {
			String brLabel = v.getBranchLabel();
			if (brLabel != null && brLabel.equals(branchLabel)
					&& !v.hasChildWithSameBranchLabel())
				return v;
		}
		return null;
	}

	/**
	 * return all versions that have no children
	 */
	public List<Version> getLastVersions() {
		List<Version> allVersions = new ArrayList<Version>();
		for (Version v : getAllVersion()) {
			if (v.getAllChildren().length == 0)
				allVersions.add(v);
		}
		return allVersions;
	}

	public List<UserImpl> getListLastModifiedBy() {
		List<UserImpl> result = new ArrayList<UserImpl>();
		for (Version v : getLastVersions())
			result.add(v.getUser());
		return result;
	}

	/**
	 * can return null
	 * 
	 * @return
	 */
	private Version getMostRecentVersion() {
		try {
			// for each Version in VersionedModel
			Calendar mostRecent = Calendar.getInstance();
			mostRecent.setTime(new Date(Long.MIN_VALUE));
			Version mostRecentVersion = null;
			for (Version v : getAllVersion()) {
				Calendar d = v.getCreationTime();
				if (d.after(mostRecent)) {
					mostRecent = d;
					mostRecentVersion = v;
				}
			}
			return mostRecentVersion;
		} catch (RDFDataException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * returns the only value. null if none is found, RDFDataException, if the
	 * property has multiple values
	 */
	public Version getRoot() throws RDFDataException {
		org.ontoware.semversion.impl.generated.Version rootVersion = this.vm
				.getRoot();
		if (rootVersion == null)
			return null;
		else
			return new Version(rootVersion);
	}

	/**
	 * when has the latest version of this versionedmodel been modified? QUERY!
	 */
	public Calendar getTimestampLastModified() {
		Version recent = getMostRecentVersion();
		return recent.getCreationTime();
	}

	// public User getLastModifiedBy() {
	// return vmi.getLastModifiedBy();
	// }

	/**
	 * get particular version from versionedmodel without having to iterate
	 * through all of the versions
	 */
	public Version getVersion(URI versionURI) {
		return new Version(vm.getModel(), versionURI, false);
	}

	public int getVersionCount() {
		Version root;
		try {
			root = getRoot();
			if (root == null) {
				log.debug("no root, no versions");
				return 0;
			}
			// recursive
			else
				return getChildrenCount(root) + 1;
		} catch (RDFDataException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * 
	 * @param start
	 *            creation
	 * @param end
	 * @param user
	 * @return the list of Versions created between start and end by user user
	 * @throws RDFDataException
	 */
	public List<Version> queryForVersions(Calendar start, Calendar end,
			User user) throws RDFDataException {
		List<Version> vis = new ArrayList<Version>();
		for (Version vi : getAllVersion()) {
			if (vi.getCreationTime().compareTo(start) >= 0
					&& vi.getCreationTime().compareTo(end) <= 0
					&& vi.getUser().equals(user))
				vis.add(vi);
		}
		return vis;
	}

	/**
	 * removes all roots
	 */
	@Deprecated
	public void removeRoot() {
		vm.removeRoot();
	}

	/**
	 * removes a value
	 */
	public void removeVersion(Version value) {
		vm.removeVersion(value.getReactorVersion());
	}

	/**
	 * removes all values and sets this one
	 */
	public void setRoot(Version value) throws RDFDataException {
		assert value != null;
		vm.setRoot(value.getReactorVersion());
	}

	public org.ontoware.semversion.impl.generated.VersionedModel getReactorVersionedModel() {
		return this.vm;
	}

	public List<Version> getVersions() {
		List<Version> vis = new ArrayList<Version>();
		for (Version vi : getAllVersion()) {
			vis.add(vi);
		}
		return vis;
	}
}
