package org.ontoware.rdfreactor.runtime;

import org.ontoware.rdf2go.model.Model;
import org.ontoware.rdf2go.model.node.BlankNode;
import org.ontoware.rdf2go.model.node.DatatypeLiteral;
import org.ontoware.rdf2go.model.node.LanguageTagLiteral;
import org.ontoware.rdf2go.model.node.Literal;
import org.ontoware.rdf2go.model.node.Node;
import org.ontoware.rdf2go.model.node.Resource;
import org.ontoware.rdf2go.model.node.URI;
import org.ontoware.rdf2go.vocabulary.RDF;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <b>ReactorBaseImpl</b> is the base class for instances of classes from the
 * RDFS/OWL schema generated by the code generator. <br>
 * 
 * If a class inheriting from ReactorBaseImpl is instantiated, it represents an
 * instance of a class from an RDFS/OWL schema. The properties of this class
 * instance are stored in an RDF model using RDF2Go (via the static Bridge
 * object) as triples of the form: (this.instanceIdentifier, key, value). <br>
 * 
 * Besides methods for putting, getting and removing properties, the Map<URI,
 * Object> Interface is also supported for handling of all properties of this
 * instance in one Map, backed by the actual RDF2Go model.
 * 
 * <br>
 * RDF Reactor uses the following naming:
 * 
 * <b>resource</b> - instance of an RDF schema class, identified by the
 * resource ID (an URI or BlankNode), almost all statements about the resource
 * use the resource ID as the object
 * 
 * <b>property</b> - a property belongs to a resource, represented by the
 * predicate of a statement about a resource
 * 
 * <b>value</b> - value of a property of a resource, represented by the object
 * of the statement with the property as predicate and the resource ID as the
 * subject
 * 
 * @author $Author: xamde $
 * @version $Id: ReactorBaseImpl.java,v 1.24 2006/12/05 19:47:28 xamde Exp $
 * 
 * 
 */
public class ReactorRuntimeEntity implements Resource {

	/**
     * 
     */
    private static final long serialVersionUID = 1L;

	private static Logger log = LoggerFactory.getLogger(ReactorRuntimeEntity.class);

	/**
	 * the underlying RDF2Go model in which the triples representing the
	 * properties of this object are saved
	 */
	protected Model model;

	/**
	 * the URI of the RDFS class from which this object is an instance
	 */
	protected URI classURI;

	/**
	 * the identifier of this instance is a URI or a BlankNode. It is used as
	 * the Subject of all triples representing this instance in the RDF model.
	 */
	private Resource instanceIdentifier;

	/**
	 * Constructor: create a ReactorBaseImpl for the RDFS/OWL schema class
	 * identified by classURI, with instanceIdentifier as the identifing URL or
	 * BlankNode.
	 * 
	 * @param model,
	 *            the underlying RDF2Go model
	 * @param classURI,
	 *            URI of the RDFS/OWL class from which this object is an
	 *            instance
	 * @param instanceIdentifier,
	 *            has to be an URI or URL or BlankNode
	 * @param write
	 *            if true, the triple (this, rdf:type, classURI) is written to
	 *            the model (in addition to any other triples denoting
	 *            properties of the instance)
	 */
	public ReactorRuntimeEntity(Model model, URI classURI,
			Resource instanceIdentifier, boolean write) {
		if( model == null)
			throw new IllegalArgumentException("model may not be null");
		if( classURI == null)
			throw new IllegalArgumentException("classURI may not be null");
		if( instanceIdentifier == null)
			throw new IllegalArgumentException("instanceIdentifier may not be null");
		
		this.model = model;
		this.classURI = classURI;
		this.instanceIdentifier = instanceIdentifier;

		// this can lead to concurrenty exceptions when used in
		// iterators on the model
		if (write) {
			try {
				// add type information only if not present
				if (!model
						.contains(this.instanceIdentifier, RDF.type, classURI)) {
					log.debug("adding type information: "
							+ this.instanceIdentifier + " a " + classURI);
					Base.add(model,instanceIdentifier,RDF.type, classURI);

				}
			} catch (Exception e) {
				throw new RuntimeException(e);
			}
		}
	}

	/**
	 * Constructor: create a ReactorBaseImpl for the RDFS/OWL schema class
	 * identified by classURI, with instanceIdentifier as the identifing URL or
	 * BlankNode. Don't write (this, rdf:type, classURI) for this instance to the
	 * model.
	 * 
	 * @param model,
	 *            the underlying RDF2Go model
	 * @param classURI,
	 *            URI of the RDFS/OWL class from which this object is an
	 *            instance
	 * @param instanceIdentifier,
	 *            has to be an URI or URL or BlankNode
	 */
	public ReactorRuntimeEntity(Model model, URI classURI,
			Resource instanceIdentifier) {
		// FIXME: default true or false?
		this(model, classURI, instanceIdentifier, false);
	}

	/**
	 * implements
	 * 
	 * @see ReactorEntity
	 */
	public Resource getResource() {
		return this.instanceIdentifier;
	}
	
	public Model getModel() {
		return this.model;
	}


	/**
	 * @return the URI of the RDFS schema class of which this object is an
	 *         instance
	 */
	public URI getRDFSClassURI() {
		return this.classURI;
	}

	// //////////////////////////////////////
	// override some java.lang.Object methods

	/**
	 * implement
	 * 
	 * @see Object methods
	 */
	@Override
	public boolean equals(Object other) {

		if (other instanceof ReactorRuntimeEntity) {
			return ((ReactorRuntimeEntity) other).getResource().equals(
					this.getResource());
		} else if (other instanceof URI) {
			return this.getResource().equals(other);
		} else
			return false;
	}

	/**
	 * implement
	 * 
	 * @see Object methods
	 */
	@Override
	public int hashCode() {
		return this.instanceIdentifier.hashCode();
	}

	/**
	 * implement
	 * 
	 * @see Object methods
	 * @return a string representation of the instance identifier (URI or blank
	 *         node). Representations are dependant on the used RDF2Go adaptor.
	 */
	@Override
	public String toString() {
		return this.instanceIdentifier.toString();
	}

	/**
	 * Cast .this object to the given target Java type.
	 * 
	 * @param targetType -
	 *            Java type to which to cast this object
	 * @return converted object
	 */
	public Object castTo(Class<?> targetType) {
		return Base.castTo(this.model, this.instanceIdentifier, targetType);
	}
	
	public boolean isInstanceof( URI classURI ) {
		return Base.hasInstance(this.model, classURI, this.instanceIdentifier);
	}

	public BlankNode asBlankNode() throws ClassCastException {
		return this.instanceIdentifier.asBlankNode();
	}

	public DatatypeLiteral asDatatypeLiteral() throws ClassCastException {
		return this.instanceIdentifier.asDatatypeLiteral();
	}

	public LanguageTagLiteral asLanguageTagLiteral() throws ClassCastException {
		return this.instanceIdentifier.asLanguageTagLiteral();
	}

	public Literal asLiteral() throws ClassCastException {
		return this.instanceIdentifier.asLiteral();
	}

	public Resource asResource() throws ClassCastException {
		return this.instanceIdentifier.asResource();
	}

	public URI asURI() throws ClassCastException {
		return this.instanceIdentifier.asURI();
	}

	public int compareTo(Node o) {
		return this.instanceIdentifier.compareTo(o);
	}

	public String toSPARQL() {
		return this.instanceIdentifier.toSPARQL();
	}

}
